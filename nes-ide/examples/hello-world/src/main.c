/* Minimal NES hello-world with visible diagnostics.
 * Enhancements:
 *  - Fills entire background nametable with tile 0 so something is always shown.
 *  - Cycles the universal background color through a small palette each frame.
 *  - Leaves CHR upload explicit for clarity.
 */

#include "nes.h"

/* Define sprite (OAM) registers if nes.h doesn't provide them */
#ifndef OAMADDR
#define OAMADDR (*(volatile unsigned char*)0x2003)
#endif
#ifndef OAMDATA
#define OAMDATA (*(volatile unsigned char*)0x2004)
#endif

/* We now embed 3 tiles in the CHR file (generated by Makefile).
 * Tile indices:
 *  0: checker pattern (original)
 *  1: inverted checker
 *  2: solid block (used for sprite)
 */

void main(void) {
    unsigned short pattern_addr = 0x0000;   /* pattern table 0 */
    unsigned short nt0 = 0x2000;            /* nametable 0 base */
    unsigned char frame = 0;
    unsigned char x = 40;                  /* sprite X */
    unsigned char dir = 1;                 /* movement direction */

    /* Wait for initial vblank */
    ppu_wait_nmi();

    /* Fill entire nametable with checkerboard using tiles 0 and 1 */
    {
        unsigned short count = 32 * 30; /* excludes attribute table */
        unsigned short i;
        PPUADDR = (unsigned char)((nt0 >> 8) & 0xFF);
        PPUADDR = (unsigned char)(nt0 & 0xFF);
        for (i = 0; i < count; ++i) {
            unsigned char t = ((i & 1) ^ ((i/32) & 1)) ? 1 : 0; /* alternate per column+row */
            PPUDATA = t;
        }
    }

    /* Initial palette background color */
    pal_bg(0x0F);

    /* Enable background and sprites (bits 3 and 4). */
    PPUMASK = 0x18;

    /* Leave NMI disabled (bit 7 = 0); we poll vblank. */
    PPUCTRL = 0x00;

    /* Sprite OAM data buffer (we'll do manual writes, minimal approach) */
    /* NES OAM entry: Y, tile, attr, X ; we maintain just one sprite */
    while (1) {
        static const unsigned char cycle[] = { 0x0F, 0x01, 0x11, 0x21, 0x31, 0x30 };
        ppu_wait_nmi();

        /* Slow palette cycle: change every 32 frames */
        if ((frame & 31) == 0) {
            unsigned char color = cycle[(frame >> 5) & (sizeof(cycle)-1)];
            pal_bg(color);
        }

        /* Simple horizontal bounce for sprite */
        if (dir) {
            if (x < 220) x++; else dir = 0;
        } else {
            if (x > 10) x--; else dir = 1;
        }

        /* Write OAM directly (no DMA helper) */
        OAMADDR = 0x00;            /* start of OAM */
        OAMDATA = 120;             /* Y (screen line, sprite appears at Y) */
        OAMDATA = 2;               /* tile index 2 (solid) */
        OAMDATA = 0x00;            /* attributes: palette 0, no flip */
        OAMDATA = x;               /* X */

        frame++;
    }
}
